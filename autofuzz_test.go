package uplink

// Edit if desired. Code generated by "fzgen storj.io/uplink".

import (
	"context"
	"testing"

	"github.com/thepudds/fzgen/fuzzer"
)

func Fuzz_Access_OverrideEncryptionKey(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var access string
		var bucket string
		var prefix string
		var encryptionKey *EncryptionKey
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&access, &bucket, &prefix, &encryptionKey)
		if encryptionKey == nil {
			return
		}

		a1, err := ParseAccess(access)
		if err != nil {
			return
		}
		a1.OverrideEncryptionKey(bucket, prefix, encryptionKey)
	})
}

func Fuzz_Access_SatelliteAddress(f *testing.F) {
	f.Fuzz(func(t *testing.T, access string) {
		a1, err := ParseAccess(access)
		if err != nil {
			return
		}
		a1.SatelliteAddress()
	})
}

func Fuzz_Access_Serialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, access string) {
		a1, err := ParseAccess(access)
		if err != nil {
			return
		}
		a1.Serialize()
	})
}

func Fuzz_Access_Share(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var access string
		var permission Permission
		var prefixes []SharePrefix
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&access, &permission, &prefixes)

		a1, err := ParseAccess(access)
		if err != nil {
			return
		}
		a1.Share(permission, prefixes...)
	})
}

func Fuzz_BucketIterator_Err(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var buckets *BucketIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&buckets)
		if buckets == nil {
			return
		}

		buckets.Err()
	})
}

func Fuzz_BucketIterator_Item(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var buckets *BucketIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&buckets)
		if buckets == nil {
			return
		}

		buckets.Item()
	})
}

func Fuzz_BucketIterator_Next(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var buckets *BucketIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&buckets)
		if buckets == nil {
			return
		}

		buckets.Next()
	})
}

func Fuzz_Download_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var download *Download
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&download)
		if download == nil {
			return
		}

		download.Close()
	})
}

func Fuzz_Download_Info(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var download *Download
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&download)
		if download == nil {
			return
		}

		download.Info()
	})
}

func Fuzz_Download_Read(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var download *Download
		var p []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&download, &p)
		if download == nil {
			return
		}

		download.Read(p)
	})
}

func Fuzz_ObjectIterator_Err(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var objects *ObjectIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&objects)
		if objects == nil {
			return
		}

		objects.Err()
	})
}

func Fuzz_ObjectIterator_Item(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var objects *ObjectIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&objects)
		if objects == nil {
			return
		}

		objects.Item()
	})
}

func Fuzz_ObjectIterator_Next(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var objects *ObjectIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&objects)
		if objects == nil {
			return
		}

		objects.Next()
	})
}

func Fuzz_PartIterator_Err(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var parts *PartIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&parts)
		if parts == nil {
			return
		}

		parts.Err()
	})
}

func Fuzz_PartIterator_Item(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var parts *PartIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&parts)
		if parts == nil {
			return
		}

		parts.Item()
	})
}

func Fuzz_PartIterator_Next(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var parts *PartIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&parts)
		if parts == nil {
			return
		}

		parts.Next()
	})
}

func Fuzz_PartUpload_Abort(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var upload *PartUpload
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&upload)
		if upload == nil {
			return
		}

		upload.Abort()
	})
}

func Fuzz_PartUpload_Commit(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var upload *PartUpload
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&upload)
		if upload == nil {
			return
		}

		upload.Commit()
	})
}

func Fuzz_PartUpload_Info(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var upload *PartUpload
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&upload)
		if upload == nil {
			return
		}

		upload.Info()
	})
}

func Fuzz_PartUpload_SetETag(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var upload *PartUpload
		var etag []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&upload, &etag)
		if upload == nil {
			return
		}

		upload.SetETag(etag)
	})
}

func Fuzz_PartUpload_Write(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var upload *PartUpload
		var p []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&upload, &p)
		if upload == nil {
			return
		}

		upload.Write(p)
	})
}

func Fuzz_Project_AbortUpload(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var key string
		var uploadID string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &key, &uploadID)
		if access == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.AbortUpload(c3, bucket, key, uploadID)
	})
}

func Fuzz_Project_BeginUpload(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var key string
		var options *UploadOptions
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &key, &options)
		if access == nil || options == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.BeginUpload(c3, bucket, key, options)
	})
}

func Fuzz_Project_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var access *Access
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &access)
		if access == nil {
			return
		}

		project, err := OpenProject(ctx, access)
		if err != nil {
			return
		}
		project.Close()
	})
}

func Fuzz_Project_CommitUpload(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var key string
		var uploadID string
		var opts *CommitUploadOptions
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &key, &uploadID, &opts)
		if access == nil || opts == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.CommitUpload(c3, bucket, key, uploadID, opts)
	})
}

func Fuzz_Project_CreateBucket(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket)
		if access == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.CreateBucket(c3, bucket)
	})
}

func Fuzz_Project_DeleteBucket(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket)
		if access == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.DeleteBucket(c3, bucket)
	})
}

func Fuzz_Project_DeleteBucketWithObjects(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket)
		if access == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.DeleteBucketWithObjects(c3, bucket)
	})
}

func Fuzz_Project_DeleteObject(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var key string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &key)
		if access == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.DeleteObject(c3, bucket, key)
	})
}

func Fuzz_Project_DownloadObject(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var key string
		var options *DownloadOptions
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &key, &options)
		if access == nil || options == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.DownloadObject(c3, bucket, key, options)
	})
}

func Fuzz_Project_EnsureBucket(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket)
		if access == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.EnsureBucket(c3, bucket)
	})
}

func Fuzz_Project_ListBuckets(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var options *ListBucketsOptions
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &options)
		if access == nil || options == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.ListBuckets(c3, options)
	})
}

func Fuzz_Project_ListObjects(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var options *ListObjectsOptions
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &options)
		if access == nil || options == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.ListObjects(c3, bucket, options)
	})
}

func Fuzz_Project_ListUploadParts(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var key string
		var uploadID string
		var options *ListUploadPartsOptions
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &key, &uploadID, &options)
		if access == nil || options == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.ListUploadParts(c3, bucket, key, uploadID, options)
	})
}

func Fuzz_Project_ListUploads(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var options *ListUploadsOptions
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &options)
		if access == nil || options == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.ListUploads(c3, bucket, options)
	})
}

func Fuzz_Project_MoveObject(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var oldbucket string
		var oldkey string
		var newbucket string
		var newkey string
		var options *MoveObjectOptions
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &oldbucket, &oldkey, &newbucket, &newkey, &options)
		if access == nil || options == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.MoveObject(c3, oldbucket, oldkey, newbucket, newkey, options)
	})
}

func Fuzz_Project_RevokeAccess(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var a2 *Access
		var c3 context.Context
		var a4 *Access
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &a2, &c3, &a4)
		if a2 == nil || a4 == nil {
			return
		}

		project, err := OpenProject(c1, a2)
		if err != nil {
			return
		}
		project.RevokeAccess(c3, a4)
	})
}

func Fuzz_Project_StatBucket(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket)
		if access == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.StatBucket(c3, bucket)
	})
}

func Fuzz_Project_StatObject(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var key string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &key)
		if access == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.StatObject(c3, bucket, key)
	})
}

func Fuzz_Project_UpdateObjectMetadata(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var key string
		var newMetadata CustomMetadata
		var options *UploadObjectMetadataOptions
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &key, &newMetadata, &options)
		if access == nil || options == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.UpdateObjectMetadata(c3, bucket, key, newMetadata, options)
	})
}

func Fuzz_Project_UploadObject(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var key string
		var options *UploadOptions
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &key, &options)
		if access == nil || options == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.UploadObject(c3, bucket, key, options)
	})
}

func Fuzz_Project_UploadPart(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var access *Access
		var c3 context.Context
		var bucket string
		var key string
		var uploadID string
		var partNumber uint32
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &access, &c3, &bucket, &key, &uploadID, &partNumber)
		if access == nil {
			return
		}

		project, err := OpenProject(c1, access)
		if err != nil {
			return
		}
		project.UploadPart(c3, bucket, key, uploadID, partNumber)
	})
}

func Fuzz_Upload_Abort(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var upload *Upload
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&upload)
		if upload == nil {
			return
		}

		upload.Abort()
	})
}

func Fuzz_Upload_Commit(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var upload *Upload
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&upload)
		if upload == nil {
			return
		}

		upload.Commit()
	})
}

func Fuzz_Upload_Info(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var upload *Upload
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&upload)
		if upload == nil {
			return
		}

		upload.Info()
	})
}

func Fuzz_Upload_SetCustomMetadata(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var upload *Upload
		var ctx context.Context
		var custom CustomMetadata
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&upload, &ctx, &custom)
		if upload == nil {
			return
		}

		upload.SetCustomMetadata(ctx, custom)
	})
}

func Fuzz_Upload_Write(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var upload *Upload
		var p []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&upload, &p)
		if upload == nil {
			return
		}

		upload.Write(p)
	})
}

func Fuzz_UploadIterator_Err(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var uploads *UploadIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&uploads)
		if uploads == nil {
			return
		}

		uploads.Err()
	})
}

func Fuzz_UploadIterator_Item(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var uploads *UploadIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&uploads)
		if uploads == nil {
			return
		}

		uploads.Item()
	})
}

func Fuzz_UploadIterator_Next(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var uploads *UploadIterator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&uploads)
		if uploads == nil {
			return
		}

		uploads.Next()
	})
}

func Fuzz_Config_OpenProject(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config Config
		var ctx context.Context
		var access *Access
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &ctx, &access)
		if access == nil {
			return
		}

		config.OpenProject(ctx, access)
	})
}

func Fuzz_Config_RequestAccessWithPassphrase(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config Config
		var ctx context.Context
		var satelliteAddress string
		var apiKey string
		var passphrase string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &ctx, &satelliteAddress, &apiKey, &passphrase)

		config.RequestAccessWithPassphrase(ctx, satelliteAddress, apiKey, passphrase)
	})
}

func Fuzz_CustomMetadata_Clone(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var meta CustomMetadata
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&meta)

		meta.Clone()
	})
}

func Fuzz_CustomMetadata_Verify(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var meta CustomMetadata
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&meta)

		meta.Verify()
	})
}

func Fuzz_DeriveEncryptionKey(f *testing.F) {
	f.Fuzz(func(t *testing.T, passphrase string, salt []byte) {
		DeriveEncryptionKey(passphrase, salt)
	})
}

func Fuzz_OpenProject(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var access *Access
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &access)
		if access == nil {
			return
		}

		OpenProject(ctx, access)
	})
}

func Fuzz_ParseAccess(f *testing.F) {
	f.Fuzz(func(t *testing.T, access string) {
		ParseAccess(access)
	})
}

func Fuzz_RequestAccessWithPassphrase(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var satelliteAddress string
		var apiKey string
		var passphrase string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &satelliteAddress, &apiKey, &passphrase)

		RequestAccessWithPassphrase(ctx, satelliteAddress, apiKey, passphrase)
	})
}
